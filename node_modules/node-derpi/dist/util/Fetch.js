"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const User_1 = require("../api/User");
const Tag_1 = require("../api/Tag");
const Image_1 = require("../api/Image");
const URLs = require("../util/URLs");
const Consts = require("../util/Consts");
const Helpers = require("../util/Helpers");
const SearchResults_1 = require("../api/SearchResults");
const ImageComments_1 = require("../api/ImageComments");
const DefaultFilters_1 = require("./DefaultFilters");
const request = require("request");
const json2typescript_1 = require("json2typescript");
/**
 * Represents various sort formats for results
 *
 * @export
 * @enum {number}
 */
var ResultSortFormat;
(function (ResultSortFormat) {
    ResultSortFormat["CREATION_DATE"] = "created_at";
    ResultSortFormat["SCORE"] = "score";
    ResultSortFormat["WILSON_SCORE"] = "wilson";
    ResultSortFormat["RELEVANCE"] = "relevance";
    ResultSortFormat["WIDTH"] = "width";
    ResultSortFormat["HEIGHT"] = "height";
    ResultSortFormat["COMMENTS"] = "comments";
    ResultSortFormat["RANDOM"] = "random";
})(ResultSortFormat = exports.ResultSortFormat || (exports.ResultSortFormat = {}));
/**
 * Represents sort orders Derpibooru allows you tu sort results by
 *
 * @export
 * @enum {number}
 */
var ResultSortOrder;
(function (ResultSortOrder) {
    ResultSortOrder["ASCENDING"] = "asc";
    ResultSortOrder["DESCENDING"] = "desc";
})(ResultSortOrder = exports.ResultSortOrder || (exports.ResultSortOrder = {}));
/**
 * Represents the maximum number of retries for ID fetching
 *
 * @private
 */
const MAXIUMUM_ID_FETCH_RETRIES = 10;
/**
 * Various functions for fetching information from Derpibooru
 *
 * @export
 * @class Fetch
 */
class Fetch {
    /**
     * Sets up some basic settings for the Fetch instance
     *
     * YOU SHOULD NOT NEED TO CALL THIS YOURSELF. IT IS DONE AT MODULE INITIALIZATION TIME.
     *
     * @static
     * @memberof Fetch
     */
    static setup() {
        this.jsonConvert.valueCheckingMode = json2typescript_1.ValueCheckingMode.ALLOW_NULL;
    }
    /**
     * Fetches an image and its associated details
     *
     * @static
     * @param {string} id The ID of the image to fetch
     * @returns {Promise<Image>} A Promise wrapping the fetched image
     * @memberof Fetch
     */
    static fetchImage(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                uri: URLs.IMAGE_URL.replace('{}', id)
            };
            const json = yield this.fetchJSON(Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options));
            return this.jsonConvert.deserializeObject(json, Image_1.Image);
        });
    }
    /**
     * Fetches a user and their associated details by name
     *
     * @static
     * @param {string} identifier The username of the user to fetch
     * @returns {Promise<User>} A Promise wrapping the fetched user
     * @memberof Fetch
     */
    static fetchUser(username) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                uri: URLs.USER_URL.replace('{}', Helpers.slugify(username))
            };
            const json = yield this.fetchJSON(Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options));
            return this.jsonConvert.deserializeObject(json, User_1.User);
        });
    }
    /**
     * Fetches a user and its associated details by ID
     *
     * THIS IS A VERY VERY VERY DIRTY HACK, BUT DERPIBOORU'S API DESIGN REQUIRES ITS EXISTENCE!
     * I'M SORRY!
     *
     * @static
     * @param {number} id The ID of the user to fetch
     * @returns {Promise<Tag>} A Promise wrapping the fetched user
     * @memberof Fetch
     */
    static fetchUserByID(id) {
        return __awaiter(this, void 0, void 0, function* () {
            let curId = '0' + id;
            if (this.userIDToURLMap.has(id)) {
                curId = this.userIDToURLMap.get(id);
            }
            const options = {
                uri: URLs.USER_URL.replace('{}', curId)
            };
            let requestOptions = Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options);
            let json = yield this.fetchJSON(requestOptions);
            let loopCount = 0;
            while (json.id !== id) {
                curId = '0' + curId;
                requestOptions.uri = URLs.USER_URL.replace('{}', curId);
                json = yield this.fetchJSON(requestOptions);
                loopCount++;
                if (loopCount >= MAXIUMUM_ID_FETCH_RETRIES) {
                    throw new Error('Maximum number of fetch attempts exceeded - blame Derpibooru for allowing name -> ID collisions.');
                }
            }
            if (!this.userIDToURLMap.has(id)) {
                this.userIDToURLMap.set(id, curId);
            }
            return this.jsonConvert.deserializeObject(json, User_1.User);
        });
    }
    /**
     * Fetches a tag and its associated details by name
     *
     * @static
     * @param {string} identifier The name of the tag to fetch
     * @param {number} [page] The page of images to fetch
     * @param {filterID} [filterID] The filter ID to apply to results
     * @returns {Promise<Tag>} A Promise wrapping the fetched tag
     * @memberof Fetch
     */
    static fetchTag(name, page, filterID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (page === undefined)
                page = 1;
            if (filterID === undefined)
                filterID = DefaultFilters_1.DefaultFilters.DEFAULT;
            const options = {
                uri: URLs.TAG_URL.replace('{}', Helpers.slugify(name)),
                qs: {
                    page: page,
                    filter_id: filterID
                }
            };
            const json = yield this.fetchJSON(Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options));
            let tag = this.jsonConvert.deserializeObject(json, Tag_1.Tag);
            tag.filterID = filterID;
            tag.nextPage = page + 1;
            return tag;
        });
    }
    /**
     * Fetches a tag and its associated details by ID
     *
     * THIS IS A VERY VERY VERY DIRTY HACK, BUT DERPIBOORU'S API DESIGN REQUIRES ITS EXISTENCE!
     * I'M SORRY!
     *
     * @static
     * @param {number} id The ID of the tag to fetch
     * @param {number} [page] The page of images to fetch
     * @param {filterID} [filterID] The filter ID to apply to results
     * @returns {Promise<Tag>} A Promise wrapping the fetched tag
     * @memberof Fetch
     */
    static fetchTagByID(id, page, filterID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (page === undefined)
                page = 1;
            if (filterID === undefined)
                filterID = DefaultFilters_1.DefaultFilters.DEFAULT;
            let curId = '0' + id;
            if (this.tagIDToURLMap.has(id)) {
                curId = this.tagIDToURLMap.get(id);
            }
            const options = {
                uri: URLs.TAG_URL.replace('{}', curId),
                qs: {
                    page: page,
                    filter_id: filterID
                }
            };
            let requestOptions = Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options);
            let json = yield this.fetchJSON(requestOptions);
            let loopCount = 0;
            while (json.tag.id !== id) {
                curId = '0' + curId;
                requestOptions.uri = URLs.TAG_URL.replace('{}', curId);
                json = yield this.fetchJSON(requestOptions);
                loopCount++;
                if (loopCount >= MAXIUMUM_ID_FETCH_RETRIES) {
                    throw new Error('Maximum number of fetch attempts exceeded - blame Derpibooru for allowing name -> ID collisions.');
                }
            }
            if (!this.tagIDToURLMap.has(id)) {
                this.tagIDToURLMap.set(id, curId);
            }
            let tag = this.jsonConvert.deserializeObject(json, Tag_1.Tag);
            tag.filterID = filterID;
            tag.nextPage = page + 1;
            return tag;
        });
    }
    /**
     * Searches for a set of images matching the given query
     *
     * @static
     * @see SearchOptions
     * @param {SearchOptions} searchOptions The options to search with
     * @returns {Promise<SearchResults>} A Promise wrapping the search results
     * @memberof Fetch
     */
    static search(searchOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let { query, sortFormat, sortOrder, page, filterID } = searchOptions;
            if (query === undefined || query === '')
                query = '*';
            if (sortFormat === undefined)
                sortFormat = ResultSortFormat.CREATION_DATE;
            if (sortOrder === undefined)
                sortOrder = ResultSortOrder.DESCENDING;
            if (page === undefined)
                page = 0;
            if (filterID === undefined)
                filterID = DefaultFilters_1.DefaultFilters.DEFAULT;
            const options = {
                uri: URLs.SEARCH_URL,
                qs: {
                    q: query,
                    sf: sortFormat,
                    sd: sortOrder,
                    page: page,
                    filter_id: filterID
                }
            };
            const json = yield this.fetchJSON(Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options));
            let searchResults = this.jsonConvert.deserializeObject(json, SearchResults_1.SearchResults);
            searchResults.nextPage = page + 1;
            searchResults.query = query;
            searchResults.sortFormat = sortFormat;
            searchResults.sortOrder = sortOrder;
            searchResults.filterID = filterID;
            return searchResults;
        });
    }
    /**
     * Fetches the comments on an image
     *
     * @static
     * @param {number} imageID The ID of the image to fetch comments from
     * @param {(number)} [page] The page of comments to fetch
     * @returns {Promise<ImageComments>}
     * @memberof Fetch
     */
    static fetchComments(imageID, page) {
        return __awaiter(this, void 0, void 0, function* () {
            if (page === undefined)
                page = 1;
            const options = {
                uri: URLs.COMMENTS_URL.replace('{}', '' + imageID),
                qs: {
                    page: page
                }
            };
            const json = yield this.fetchJSON(Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options));
            let comments = this.jsonConvert.deserializeObject(json, ImageComments_1.ImageComments);
            comments.nextPage = page + 1;
            comments.imageID = imageID;
            return comments;
        });
    }
    /**
     * Boilerplate to fetch JSON data from Derpibooru
     *
     * @static
     * @private
     * @param {request.UriOptions} options Options for the request
     * @returns {Promise<any>} A Promise wrapping the returned data
     * @memberof Fetch
     */
    static fetchJSON(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const opts = Object.assign({}, Consts.DEFAULT_REQUEST_OPTS, options);
                request.get(opts, (err, response, body) => {
                    if (err) {
                        return reject(err);
                    }
                    const status = response.statusCode;
                    if (status !== Consts.HTTP_200_OK && status !== Consts.HTTP_301_MOVED_PERMANENTLY) {
                        return reject(new Error(`Received status code ${status}`));
                    }
                    return resolve(body);
                });
            });
        });
    }
}
Fetch.jsonConvert = new json2typescript_1.JsonConvert();
Fetch.tagIDToURLMap = new Map();
Fetch.userIDToURLMap = new Map();
exports.Fetch = Fetch;
